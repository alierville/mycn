"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const METHODS=["run","get","all","exec","each","prepare","migrate"];async function doCreateConnection(e,n){let o={},t=!n,r=!1;for(let t of METHODS)o[t]=(async(...o)=>{if(r)throw new Error(`Invalid call to "${t}", the connection is closed`);return(n||e.singleUse)[t](...o)});o.singleRow=(async(e,n)=>{let t=await o.all(e);if(1!==t.length){if("acceptMissingRow"===n&&0===t.length)return;throw new Error(`Cannot fetch one value, row count: ${t.length}`)}return t[0]}),o.singleValue=(async(e,n)=>{let t=await o.singleRow(e,n);if("acceptMissingRow"===n&&void 0===t)return;let r=Object.keys(t);if(1!==r.length)throw new Error(`Cannot fetch one value, column count: ${r.length}`);return t[r[0]]});let a,l=!1;if(n){a=1,await n.exec("begin");for(let t of["commit","rollback"])o[t]=(async()=>{if(r)throw new Error(`Invalid call to "${t}", the connection is closed`);if(0===a)throw new Error(`Cannot ${t}, not in a transaction`);if(0===--a){let o=l&&"commit"===t;if(await n.exec(o?"rollback":t),e.release(n),n=void 0,o)throw new Error('Invalid call to "commit", because an inner transaction has been rollbacked')}else"rollback"===t&&(l=!0)})}else a=0;return o.beginTransaction=(async(n=!1)=>{if(r)throw new Error('Invalid call to "beginTransaction", the connection is closed');if(a>0)throw new Error("Cannot open a transaction in a transaction");return await doCreateConnection(e,await e.grab())}),o.close=(async()=>{if(r)throw new Error('Invalid call to "close", the connection is already closed');let a;n&&(a=o.rollback()),r=!0,a&&await a,t&&await e.close()}),Object.defineProperties(o,{inTransaction:{configurable:!1,enumerable:!0,get:function(){return a>0}}}),o}async function createPool(e,n){n.logError||(n.logError=console.log),n.connectionTtl||(n.connectionTtl=60);let o=!1,t=await e(),r=[],a=null;return{get singleUse(){if(o)throw new Error("Cannot use the main connection, the pool is closed");return t},grab:async()=>{if(o)throw new Error('Invalid call to "grab", the pool is closed');let n=r.pop();return n?n.db:e()},release:e=>{r.push({db:e,releaseTime:Date.now()}),o?l(!0):function(){if(null!==a)return;a=setInterval(()=>{l(),0===r.length&&(clearInterval(a),a=null)},2e4)}()},close:async()=>{if(o)throw new Error('Invalid call to "close", the pool is already closed');o=!0,await t.close()}};function l(e=!1){let o,t=Date.now()-1e3*n.connectionTtl;for(o=0;o<r.length&&(e||!(r[o].releaseTime>t));++o)r[o].db.close().catch(n.logError);o>0&&(r=r.slice(o))}}async function sqliteConnection(e,n={}){return await doCreateConnection(await createPool(e,n))}exports.sqliteConnection=sqliteConnection;